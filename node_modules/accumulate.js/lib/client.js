"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const acc_url_1 = require("./acc-url");
const acme_1 = require("./acme");
const api_types_1 = require("./api-types");
const add_credits_1 = require("./payload/add-credits");
const add_validator_1 = require("./payload/add-validator");
const burn_tokens_1 = require("./payload/burn-tokens");
const create_data_account_1 = require("./payload/create-data-account");
const create_identity_1 = require("./payload/create-identity");
const create_key_book_1 = require("./payload/create-key-book");
const create_key_page_1 = require("./payload/create-key-page");
const create_token_1 = require("./payload/create-token");
const create_token_account_1 = require("./payload/create-token-account");
const issue_tokens_1 = require("./payload/issue-tokens");
const remove_validator_1 = require("./payload/remove-validator");
const send_tokens_1 = require("./payload/send-tokens");
const update_account_auth_1 = require("./payload/update-account-auth");
const update_key_1 = require("./payload/update-key");
const update_key_page_1 = require("./payload/update-key-page");
const update_validator_key_1 = require("./payload/update-validator-key");
const write_data_1 = require("./payload/write-data");
const rpc_client_1 = require("./rpc-client");
const transaction_1 = require("./transaction");
const util_1 = require("./util");
/**
 * Client to call Accumulate RPC APIs.
 */
class Client {
    constructor(endpoint) {
        this._rpcClient = new rpc_client_1.RpcClient(endpoint);
    }
    /**
     * Direct RPC call.
     * @param method RPC method
     * @param params method parameters
     */
    call(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._rpcClient.call(method, params);
        });
    }
    /******************
     * Queries
     ******************/
    queryAcmeOracle() {
        return this.queryData(acme_1.ACME_ORACLE_URL).then((r) => JSON.parse(Buffer.from(r.data.entry.data[0], "hex").toString()).price);
    }
    queryUrl(url, options) {
        const urlStr = url.toString();
        return this.call("query", Object.assign({ url: urlStr }, options));
    }
    queryTx(txId, options) {
        return this.call("query-tx", Object.assign({ txid: txId }, options));
    }
    queryTxHistory(url, pagination) {
        const urlStr = url.toString();
        return this.call("query-tx-history", Object.assign({ url: urlStr }, pagination));
    }
    queryDirectory(url, pagination, options) {
        return this.call("query-directory", Object.assign(Object.assign({ url: url.toString() }, pagination), options));
    }
    queryData(url, entryHash) {
        return this.call("query-data", {
            url: url.toString(),
            entryHash,
        });
    }
    queryDataSet(url, pagination, options) {
        return this.call("query-data-set", Object.assign(Object.assign({ url: url.toString() }, pagination), options));
    }
    queryKeyPageIndex(url, key) {
        const urlStr = url.toString();
        const keyStr = key instanceof Uint8Array ? Buffer.from(key).toString("hex") : key;
        return this.call("query-key-index", {
            url: urlStr,
            key: keyStr,
        });
    }
    queryMinorBlocks(url, pagination, options) {
        return this.call("query-minor-blocks", Object.assign(Object.assign({ url: url.toString() }, pagination), options));
    }
    querySignerVersion(signer, publicKeyHash) {
        return __awaiter(this, void 0, void 0, function* () {
            let signerUrl;
            let pkh;
            if (signer instanceof acc_url_1.AccURL) {
                signerUrl = signer;
                if (!publicKeyHash) {
                    throw new Error("Missing public key hash");
                }
                pkh = publicKeyHash;
            }
            else {
                signerUrl = signer.url;
                pkh = signer.publicKeyHash;
            }
            const { data: { keyPage }, } = yield this.queryKeyPageIndex(signerUrl, pkh);
            const res = yield this.queryUrl(keyPage);
            return res.data.version;
        });
    }
    /**
     * Wait for a transaction (and its associated synthetic tx ids) to be delivered.
     * Throw an error if the transaction has failed or the timeout is exhausted.
     * @param txId
     * @param options
     * @returns void
     */
    waitOnTx(txId, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            // Options
            const to = (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : 30000;
            const pollInterval = (_b = options === null || options === void 0 ? void 0 : options.pollInterval) !== null && _b !== void 0 ? _b : 500;
            const ignoreSyntheticTxs = (_c = options === null || options === void 0 ? void 0 : options.ignoreSyntheticTxs) !== null && _c !== void 0 ? _c : false;
            const start = Date.now();
            let lastError;
            do {
                try {
                    const { status, syntheticTxids } = yield this.queryTx(txId);
                    if (!status.delivered) {
                        throw new Error("Transaction not delivered");
                    }
                    if (status.code) {
                        throw new api_types_1.TxError(txId, status);
                    }
                    if (ignoreSyntheticTxs) {
                        return;
                    }
                    // Also verify the associated synthetic txs
                    const timeoutLeft = to - Date.now() + start;
                    const stxIds = syntheticTxids || [];
                    yield Promise.all(stxIds.map((stxId) => this.waitOnTx(stxId, {
                        timeout: timeoutLeft,
                        pollInterval: options === null || options === void 0 ? void 0 : options.pollInterval,
                        ignoreSyntheticTxs: options === null || options === void 0 ? void 0 : options.ignoreSyntheticTxs,
                    })));
                    return;
                }
                catch (e) {
                    // Do not retry on definitive transaction errors
                    if (e instanceof api_types_1.TxError) {
                        throw e;
                    }
                    lastError = e;
                    yield (0, util_1.sleep)(pollInterval);
                }
                // Poll while timeout is not reached
            } while (Date.now() - start < to);
            throw new Error(`Transaction ${txId} was not confirmed within ${to / 1000}s. Cause: ${lastError}`);
        });
    }
    /******************
     * Transactions
     ******************/
    addCredits(principal, addCredits, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new add_credits_1.AddCredits(addCredits), signer);
    }
    addValidator(principal, addValidator, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new add_validator_1.AddValidator(addValidator), signer);
    }
    burnTokens(principal, burnTokens, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new burn_tokens_1.BurnTokens(burnTokens), signer);
    }
    createDataAccount(principal, createDataAccount, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new create_data_account_1.CreateDataAccount(createDataAccount), signer);
    }
    createIdentity(principal, createIdentity, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new create_identity_1.CreateIdentity(createIdentity), signer);
    }
    createKeyBook(principal, createKeyBook, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new create_key_book_1.CreateKeyBook(createKeyBook), signer);
    }
    createKeyPage(principal, createKeyPage, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new create_key_page_1.CreateKeyPage(createKeyPage), signer);
    }
    createToken(principal, createToken, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new create_token_1.CreateToken(createToken), signer);
    }
    createTokenAccount(principal, createTokenAccount, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new create_token_account_1.CreateTokenAccount(createTokenAccount), signer);
    }
    execute(tx) {
        return this.call("execute", tx.toTxRequest());
    }
    issueTokens(principal, issueTokens, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new issue_tokens_1.IssueTokens(issueTokens), signer);
    }
    removeValidator(principal, removeValidator, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new remove_validator_1.RemoveValidator(removeValidator), signer);
    }
    sendTokens(principal, sendTokens, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new send_tokens_1.SendTokens(sendTokens), signer);
    }
    updateAccountAuth(principal, operation, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new update_account_auth_1.UpdateAccountAuth(operation), signer);
    }
    updateKey(principal, updateKey, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new update_key_1.UpdateKey(updateKey), signer);
    }
    updateKeyPage(principal, operation, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new update_key_page_1.UpdateKeyPage(operation), signer);
    }
    updateValidatorKey(principal, updateValidatorKey, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new update_validator_key_1.UpdateValidatorKey(updateValidatorKey), signer);
    }
    writeData(principal, writeData, signer) {
        return this._execute(acc_url_1.AccURL.toAccURL(principal), new write_data_1.WriteData(writeData), signer);
    }
    _execute(principal, payload, signer) {
        return __awaiter(this, void 0, void 0, function* () {
            const header = new transaction_1.Header(principal);
            const tx = new transaction_1.Transaction(payload, header);
            yield tx.sign(signer);
            return this.execute(tx);
        });
    }
    /******************
     * Others
     ******************/
    faucet(url) {
        return this.call("faucet", {
            url: url.toString(),
        });
    }
    status() {
        return this.call("status");
    }
    version() {
        return this.call("version");
    }
    describe() {
        return this.call("describe");
    }
    metrics(metric, duration) {
        return this.call("metrics", {
            metric,
            duration,
        });
    }
}
exports.Client = Client;
//# sourceMappingURL=client.js.map