"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WriteData = void 0;
const crypto_1 = require("../crypto");
const encoding_1 = require("../encoding");
const tx_types_1 = require("../tx-types");
const base_payload_1 = require("./base-payload");
class WriteData extends base_payload_1.BasePayload {
    constructor(arg) {
        super();
        this._data = arg.data;
        this._scratch = arg.scratch || false;
    }
    _marshalBinary() {
        const forConcat = [];
        forConcat.push((0, encoding_1.uvarintMarshalBinary)(tx_types_1.TransactionType.WriteData, 1));
        forConcat.push((0, encoding_1.fieldMarshalBinary)(2, marshalDataEntry(this._data)));
        if (this._scratch) {
            forConcat.push((0, encoding_1.booleanMarshalBinary)(this._scratch, 3));
        }
        return Buffer.concat(forConcat);
    }
    // Overrides default payload hash with tree hash of the entry
    hash() {
        if (this._dataHash) {
            return this._dataHash;
        }
        this._dataHash = (0, crypto_1.hashTree)(this._data);
        return this._dataHash;
    }
}
exports.WriteData = WriteData;
function marshalDataEntry(data) {
    const forConcat = [];
    // AccumulateDataEntry DataEntryType 2
    forConcat.push((0, encoding_1.uvarintMarshalBinary)(2, 1));
    // Data
    forConcat.push(Buffer.concat(data.map((d) => (0, encoding_1.bytesMarshalBinary)(d, 3))));
    return (0, encoding_1.bytesMarshalBinary)(Buffer.concat(forConcat));
}
//# sourceMappingURL=write-data.js.map