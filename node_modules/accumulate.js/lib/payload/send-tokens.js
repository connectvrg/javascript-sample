"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SendTokens = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const acc_url_1 = require("../acc-url");
const encoding_1 = require("../encoding");
const tx_types_1 = require("../tx-types");
const base_payload_1 = require("./base-payload");
class SendTokens extends base_payload_1.BasePayload {
    constructor(arg) {
        super();
        if (arg.to.length < 1) {
            throw new Error("Missing at least one recipient");
        }
        this._to = arg.to.map((r) => ({
            url: acc_url_1.AccURL.toAccURL(r.url),
            amount: r.amount instanceof bn_js_1.default ? r.amount : new bn_js_1.default(r.amount),
        }));
        this._hash = arg.hash;
        this._meta = arg.meta;
    }
    _marshalBinary() {
        const forConcat = [];
        forConcat.push((0, encoding_1.uvarintMarshalBinary)(tx_types_1.TransactionType.SendTokens, 1));
        if (this._hash) {
            validateHash(this._hash);
            forConcat.push((0, encoding_1.hashMarshalBinary)(this._hash, 2));
        }
        if (this._meta) {
            forConcat.push((0, encoding_1.bytesMarshalBinary)(this._meta, 3));
        }
        this._to.forEach((recipient) => forConcat.push((0, encoding_1.fieldMarshalBinary)(4, marshalBinaryTokenRecipient(recipient))));
        return Buffer.concat(forConcat);
    }
}
exports.SendTokens = SendTokens;
function marshalBinaryTokenRecipient(tr) {
    return (0, encoding_1.bytesMarshalBinary)(Buffer.concat([(0, encoding_1.stringMarshalBinary)(tr.url.toString(), 1), (0, encoding_1.bigNumberMarshalBinary)(tr.amount, 2)]));
}
function validateHash(bytes) {
    if (bytes.length !== 32) {
        throw new Error("Invalid hash length");
    }
}
//# sourceMappingURL=send-tokens.js.map