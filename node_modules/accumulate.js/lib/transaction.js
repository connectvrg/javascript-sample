"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transaction = exports.Header = void 0;
const acc_url_1 = require("./acc-url");
const crypto_1 = require("./crypto");
const encoding_1 = require("./encoding");
const signer_1 = require("./signer");
/**
 * Transaction header
 */
class Header {
    /**
     * Construct a Transaction Header
     * @param principal principal of the transaction
     * @param options options.
     * - If timestamp is not specified it defaults to the current timestamp in microseconds.
     */
    constructor(principal, options) {
        var _a;
        this._principal = acc_url_1.AccURL.toAccURL(principal);
        this._timestamp = (_a = options === null || options === void 0 ? void 0 : options.timestamp) !== null && _a !== void 0 ? _a : Date.now() * 1000;
        this._memo = options === null || options === void 0 ? void 0 : options.memo;
        this._metadata = (options === null || options === void 0 ? void 0 : options.metadata) ? Buffer.from(options.metadata) : undefined;
    }
    get principal() {
        return this._principal;
    }
    get timestamp() {
        return this._timestamp;
    }
    get memo() {
        return this._memo;
    }
    get metadata() {
        return this._metadata;
    }
    computeInitiator(signerInfo) {
        const binary = [];
        binary.push((0, encoding_1.uvarintMarshalBinary)(signerInfo.type, 1));
        binary.push((0, encoding_1.bytesMarshalBinary)(signerInfo.publicKey, 2));
        binary.push((0, encoding_1.stringMarshalBinary)(signerInfo.url.toString(), 4));
        binary.push((0, encoding_1.uvarintMarshalBinary)(signerInfo.version, 5));
        binary.push((0, encoding_1.uvarintMarshalBinary)(this._timestamp, 6));
        this._initiator = (0, crypto_1.sha256)(Buffer.concat(binary));
        return this._initiator;
    }
    marshalBinary() {
        var _a;
        if (!this._initiator) {
            throw new Error("Initiator hash missing. Must be initilized by calling computeInitiator");
        }
        const forConcat = [];
        forConcat.push((0, encoding_1.stringMarshalBinary)(this._principal.toString(), 1));
        forConcat.push((0, encoding_1.hashMarshalBinary)(this._initiator, 2));
        if (this._memo && this._memo.length !== 0) {
            forConcat.push((0, encoding_1.stringMarshalBinary)(this._memo, 3));
        }
        if (this._metadata && ((_a = this._metadata) === null || _a === void 0 ? void 0 : _a.length) !== 0) {
            forConcat.push((0, encoding_1.bytesMarshalBinary)(this._metadata, 4));
        }
        return Buffer.concat(forConcat);
    }
}
exports.Header = Header;
/**
 * An Accumulate Transaction
 */
class Transaction {
    constructor(payload, header, signature) {
        this._payloadBinary = payload.marshalBinary();
        this._header = header;
        this._signature = signature;
        this._bodyHash = payload.hash();
    }
    /**
     * Compute the hash of the transaction
     */
    hash() {
        if (this._hash) {
            return this._hash;
        }
        const headerHash = (0, crypto_1.sha256)(this._header.marshalBinary());
        this._hash = (0, crypto_1.sha256)(Buffer.concat([headerHash, this._bodyHash]));
        return this._hash;
    }
    /**
     * Data that needs to be signed in order to submit the transaction.
     */
    dataForSignature(signerInfo) {
        const sigHash = this.header.computeInitiator(signerInfo);
        return (0, crypto_1.sha256)(Buffer.concat([sigHash, this.hash()]));
    }
    get payload() {
        return this._payloadBinary;
    }
    get principal() {
        return this._header.principal;
    }
    get header() {
        return this._header;
    }
    get signature() {
        return this._signature;
    }
    set signature(signature) {
        this._signature = signature;
    }
    sign(signer) {
        return __awaiter(this, void 0, void 0, function* () {
            this._signature = yield signer.sign(this);
        });
    }
    /**
     * Convert the Transaction into the param object for the `execute` API method
     */
    toTxRequest(checkOnly) {
        var _a, _b;
        if (!this._signature) {
            throw new Error("Unsigned transaction cannot be converted to TxRequest");
        }
        const signerInfo = this._signature.signerInfo;
        return {
            checkOnly: checkOnly ? checkOnly : undefined,
            isEnvelope: false,
            origin: this._header.principal.toString(),
            signer: {
                url: signerInfo.url.toString(),
                publicKey: Buffer.from(signerInfo.publicKey).toString("hex"),
                version: signerInfo.version,
                timestamp: this._header.timestamp,
                signatureType: (0, signer_1.signatureTypeMarshalJSON)(signerInfo.type),
                useSimpleHash: true,
            },
            signature: Buffer.from(this._signature.signature).toString("hex"),
            txHash: (_a = this._hash) === null || _a === void 0 ? void 0 : _a.toString("hex"),
            payload: this._payloadBinary.toString("hex"),
            memo: this._header.memo,
            metadata: (_b = this._header.metadata) === null || _b === void 0 ? void 0 : _b.toString("hex"),
        };
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map